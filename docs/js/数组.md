# 数组

## 检测

### 原型链视角

只要在当前对象的原型链中，找到了 `Array.prototype` ，就说明该对象是数组（至少它可以调用数组原型上的所有方法）。

所以，最简单的检测数组的方法是：

```js
const arr = [1, 2, 3]
arr instanceof Array // true
```

需要注意的是，`arr instanceof Array` 的语义不是 **`arr` 由 `Array` 构造函数构造而来** ！而是在 `arr` 的原型链中查找，直到找到 `Array.prototype` 即为 `true` ，与构造函数没有任何关系！不妨看看下方的代码：

```js
const o = Object.create(Array.prototype)
o instanceof Array // true
```

很显然，对象 `o` 不是一个数组，但是判断时却返回了 `true` 。因此，这种判断方法个人认为从合理性上分析就不够充分，何况它还有一个很严重的坑。

::: danger 坑
众所周知，iframe拥有自身的 `window` 对象，如果在主 `window` 中创建一个数组：

```js
window.arr = [1, 2, 3]
```

在iframe中，拿到此数组对象进行类型判断：

```js
window.parent.arr instanceof Array // false
```

为什么？因为主窗口与iframe拥有独立的 `window` ，因此 `window.Array` 也是独立的，继而 `window.Array.prototype` 也是独立的，两个对象不在同一块内存空间，因此判断相等时，当然为 `false` 。
:::

### Array.isArray

ES6以后新增了 `isArray` API，可以非常简单、准确地检测数组。

```js
const arr = [1, 2, 3]
Array.isArray(arr) // true
```

## 迭代

<Todo />

## 稀疏数组

```javascript
const arr = []
arr[1] = 1
arr[50] = undefined
arr[100] = 100
```
arr即为一个稀疏数组，稀疏数组的特点：

* for...of循环会按照length的长度迭代
* forEach/map/reduce等迭代api会忽略空缺的位置

## indexOf缺陷


```javascript
const arr = [1, NaN, 3]
console.log(arr.indexOf(NaN)) // -1
```
`indexOf`内部使用`===`进行比较，因为NaN不等于NaN，所以会找不到。

## 类数组

<Todo />

## 手写系列

### 手写数组所有原型方法

<Todo />

