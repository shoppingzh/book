# 执行上下文

执行上下文描述了当前代码执行的情况，了解执行上下文对于理解JavaScript的运行原理至关重要。

但是，JavaScript的运行原理是非常复杂的，有诸多关联概念，在开始学习执行上下文之前，需要充分理解以下概念：

- Environment Records：环境记录，描述当前词法环境
- Realms：领域对象，JavaScript的顶级对象

以下将先从依赖概念开始讲起，使用案例尽可能将概念讲述清楚，如有不正之处，还望读者慷慨指出！

## Environment Records

**环境记录与词法作用域息息相关** ，先看看ES规范中是怎么介绍它的：

> Environment Record is a specification type used to define the association of Identifiers to specific variables and functions, based upon the lexical nesting structure of ECMAScript code. Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement. Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.

环境记录通过代码中的嵌套结构来定义标识符与特定变量、函数的关联关系，一般来说，环境记录会在 **函数定义、块定义、catch子句** 开启时创建。


```js
function func(a) { // A区块
  if (a) { // B区块
    conosle.log(a)
  }
}
```

以上代码，创建了两个环境记录对象，一个从A区块开始时创建，一个在B区块开始时创建。 这两个环境记录的类型是不同的，后面会提到。

从这个例子可以简单认为： **每个词法作用域都对应了一个环境记录** 。

ES规范中，将环境记录分为5种，其中大类分3种，它们的关系如下：

- Declarative Environment Records：声明性环境记录，用于存储变量、函数、类、模块的声明
   - Function Environment Records：函数环境记录，声明性环境记录的子类，从函数定义的位置开始创建，与声明性环境记录明显的差别是存在 `this` 绑定
   - Module Environment Records：模块环境记录，声明性环境记录的子类，从模块定义的位置开始创建
- Object Environment Records：对象环境记录，如果当前区块通过 `with` 创建，则创建了一个对象环境记录
- Global Environment Records：全局环境记录，它是一个对象环境记录与声明性环境记录的复合体，一般而言是单例的

此外，每个环境记录对象都有一个 `[[OuterEnv]]` 属性，用来访问其上层环境记录，这其实就是 **作用域链** 的工作原理。参考以下代码：

```js
function func(a) { // A
  if (a) { // B
    let b = 1
    console.log(a + b)
  }
}

func(1)
```

上述代码在A处与B处分别创建了两个环境记录，使用代码表示类似于：

```ts
const a: FunctionEnvironmentRecord = {
  [[OuterEnv]]: null,
  a: 1
}
const b: DeclarativeEnvironmentRecord = {
  [[OuterEnv]]: a,
  b: 1
}
```

> 为了简化概念，这里视函数环境记录 `a` 的外层环境记录为空，但其实不是空，应该是全局环境记录。

当代码执行到 `console.log(a + b)` 这一行时，js引擎会尝试获取变量 `a` 的值，于是在当前的环境记录（B）中查找 `a` ，没有找到，于是继续沿着 `[[OuterEnv]]` 往上查找，在找到环境记录A时发现了变量 `a` 。这就是作用域链中变量查找的原理。

### Declarative Environment Records

```js
if (true) { // A
  const a = 1
  function inner() { // B
    console.log(a)
  }
  class Person { // C
  }
  const p = new Peson()

  if (a) { // D
    const x = 2
    console.log(x)
  }
}
```

以上代码中，从A处开始创建了第一个声明性环境记录：

```ts
const er: DeclarativeEnvironmentRecord = {
  [[OuterEnv]]: null,
  a: 1,
  inner: ?,
  Person: ?,
  p: ?,
} 
```


接着，在D处创建了第二个声明性环境记录：

```ts
const er2: DeclarativeEnvironmentRecord = {
  [[OuterEnv]]: er,
  x: 2,
}
```


### Function Environment Records

相比声明性环境记录，函数环境记录有一些特殊的属性：

| 属性 | 可选值 | 描述 |
| -- | -- | -- |
| [[ThisValue]] | 任意值，如果是基本数据类型，将装箱为对象 | 函数绑定的 `this` 值 |
| [[ThisBindingStatus]] | lexical/initialized/uninitialized | `this` 绑定状态，如果是箭头函数，为lexical |
| [[FunctionObject]] | 对象 | 当前运行的函数对象自身 |
| [[NewTarget]] | 一个对象或null | 如果当前函数通过构造函数调用，该属性有值，否则为空 |

```js
function func(a) { // A
  let b = 1
  console.log(a + b)
}

func(1)
```

如上代码，从A处开始将创建一个函数环境记录：

```ts
const fer: FunctionEnvironmentRecord = {
  [[OuterEnv]]: null,
  [[ThisValue]]: {}, // window
  [[ThisValueStatus]]: 'initialized',
  a: 1,
  b: 1,
}
```

与声明性环境记录不同的是，函数环境记录会绑定 `this` 。上面的例子中，函数 `func` 通过普通方式调用，因此其 `this` 是全局 `window` 对象。

如果函数是一个箭头函数：

```js
const func = (a) => { // A
  let b = 1
  console.log(a + b)
}

func(1)
```

此时，环境记录会有一些差异：

```ts
const fer: FunctionEnvironmentRecord = {
  [[OuterEnv]]: null,
  [[ThisValue]]: null,
  [[ThisValueStatus]]: 'lexical',
  a: 1,
  b: 1,
}
```

**箭头函数的 `this` 绑定状态永远为 `lexical` ，这意味着，箭头函数是不存在 `this` 绑定的。** 因此，当在箭头函数中使用 `this` 时，由于箭头函数的环境记录没有 `this` 绑定，因此会通过 `[[OuterEnv]]` 继续向上查找，直到查找到存在 `this` 绑定的环境记录。这是为什么常说箭头函数的 `this` 是词法的原理。



### Object Environment Records

一般来说，我们通过 `with` 语法来开启对象环境记录。参考以下代码：

```js
const o = {
  a: 1,
}
with (o) { // A
  a = 2
}

console.log(o.a) // 2
```

为什么在A处的代码中，可以通过 `a = 2` 的方式对对象 `o` 进行修改呢？这要从对象环境记录的值绑定规则说起：

**在对象环境记录中，所有的变量绑定发生在被绑定的对象中** ，如上例中， `a = 2` 等同于 `o.a = 2` 。

因为全局的环境记录本身至少是一个对象环境记录，所以解释以下代码也就不难了：

```js
a = 1

console.log(window.a) // 1
```

你可以理解为，全局范围就像在一个大的 `with` 语句包含下：

```js
with (window) {
  a = 1
  console.log(window.a) // 1
}
```

### Global Environment Records

**全局环境记录是一个复合环境记录** ，其内部持有了一个对象环境记录和一个声明性环境记录，其中：

**对象环境记录用于存储通过 `function` 、`var` 声明的函数、变量** ，如以下代码：

```js
var a = 1
function test() {
  console.log('test')
}

window.test() // test
console.log(window.a) // 1
```

但是通过 `const/let` 声明的变量不会存储在对象环境记录中，因此不会在 `global object` 中添加新的属性：

```js
const x = 1
console.log(x) // undefined
```

而除了通过 `function/var` 声明的函数/变量外，其他声明都存储在声明性环境记录中，因此在上述代码中，变量 `x` 存储在声明性环境记录中。

那么，全局环境记录是如何存储复合的环境记录的呢？在全局环境记录中，有以下特殊的属性:

| 属性 | 可选值 | 描述 |
| -- | -- | -- |
| [[ObjectRecord]] | 对象环境记录对象 | 一个绑定了全局对象的对象环境记录 |
| [[GlobalThisValue]] | 一个对象 | 全局 `this` 值 |
| [[DeclarativeRecord]] | 声明性环境记录对象 | 除了对象环境记录中的声明，其他声明记录在这个对象中 |
| [[VarNames]] | 一个string集合 | 这个集合记录了在全局代码中绑定在对象环境记录中的声明名称，以跟全局对象中默认的声明区分 |

## Realms

先看看ES规范中对Realms的介绍：

> Before it is evaluated, all ECMAScript code must be associated with a realm. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources

在运行之前，所有代码都必须与一个Realm进行关联。一个Realm包含了内置对象、全局环境、在当前全局环境下加载的代码以及一些关联状态和资源。

简单理解，**Realm是代码运行的全局环境** ，考虑以下代码：

```js
function func() {
  const arr = new Array()
  arr.push(1)
}
```



## 执行上下文

<Todo />

## 练习

<Todo />

