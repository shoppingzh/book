# 对象

## 基础

<Todo />


## 原型与原型链

<Todo />

## 属性描述符

<Todo />

## 属性迭代

<Todo />

## new操作符原理

<Todo />

## Object.create

`Object.create` 接受一个对象作为参数，返回另一个对象，返回的对象以传入的对象为原型。

```js
const person = {
  say() {
    console.log(`Hi, my name is ${this.name}`)
  }
}

const p = Object.create(person)
p.name = 'Jack'

p.say()
```

尽管变量 `p` 并没有声明 `say` 函数，但由于 `person` 对象为 `p` 对象的原型，当调用 `p.say()` 时，会在原型链查找，查找到 `person` 对象的 `say` 函数，从而调用成功。

下图展示了对象 `p` 的原型链：

![](./images/object-1.png)

**polyfill**

核心思路是 **改变返回的对象的原型为传入的对象**，因此可以从以下步骤入手：

1. 创建一个新对象
2. 将对象的 `[[Prototype]]` 指向传入对象
3. 返回该对象

```js
function objectCreate(proto) {
  const o = {}
  Object.setPrototypeOf(o, proto)
  return o
}
```

考虑到 `Object.setPrototypeOf` 在IE 11以后的版本才被实现，还可以考虑另一种方案：返回的对象通过一个构造函数创建，将此构造函数的 `prototype` 属性指向传入的对象。代码如下：

```js
function objectCreate2(proto) {
  function F() {}
  F.prototype = proto
  return new F()
}
```

## 手写系列

### 手写 `new`


**1\. 创建一个简单对象**

```js
const obj = {}
```


**2\. 设置对象的原型为构造函数的原型对象**

```js
Object.setPrototypeOf(obj, Constructor.prototype)
```

作用：这样这个简单对象才能访问到构造函数原型链上的属性、方法。

**3\. 执行构造函数**

```js
const result = Constructor.apply(obj, Array.prototype.slice.call(arguments, 1))
```
作用：创建一个对象，当然需要执行构造函数。

**4\. 返回创建后的对象**

```js
return typeof result === 'object' ? result : obj
```
如果构造函数有对象类型的返回值，返回，否则，返回这个创建的对象。



### 手写深拷贝

要点：

* 基本类型直接复制
* 对象、数组按照深度进行递归处理
* 函数的处理
* Set/Map/Date/RegExp等非plain object的处理
* 循环引用等极端情况处理（重点）

数据类型

* 基本型
   * undefined
   * null
   * number
   * string
   * boolean
   * bigint
   * symbol
* 引用型
   * Object
   * Array
   * Date
   * RegExp
   * Set
   * Map

实现代码如下：

```javascript
function isObjectType(value, type) {
  let objectType = Object.prototype.toString.call(value)
  objectType = objectType.substring(8, objectType.length - 1)
  return objectType === type
}

function isPrimitive(value) {
  return value === null || ['boolean', 'string', 'number', 'bigint', 'symbol', 'undefined'].indexOf(typeof value) >= 0
}

function isArray(value) {
  return isObjectType(value, 'Array')
}

function clone(value) {
  const refs = []
  const doClone = (val, parent) => {
    if (isPrimitive(val)) return val
    if (refs.indexOf(val) >= 0) return val
    // 特殊对象：数组
    if (isArray(val)) {
      const cloneVal = []
      for (let i = 0, len = val.length; i < len; i++) {
        cloneVal[i] = doClone(val[i])
      }
      return cloneVal
    }
    // 特殊对象：正则表达式
    if (isObjectType(val, 'RegExp')) {
      return new RegExp(val)
    }
    // 特殊对象：日期
    if (isObjectType(val, 'Date')) {
      return new Date(val)
    }

    // 普通对象
    refs.push(val)
    const cloneVal = {}
    Object.keys(val).forEach(key => {
      cloneVal[key] = doClone(val[key], val)
    })
    return cloneVal
  }
  return doClone(value)
}
```

### 手写 `instanceOf`

```ts
function instanceOf(o: any, constructor: Function): boolean {
  let curr = o
  while (curr) {
    const proto = curr.__proto__
    if (proto === constructor.prototype) return true
    curr = proto
  }
  return false
}

```

`instanceof`缺点：
- 无法检测基本数据类型，如`1 instanceof Number => false`

