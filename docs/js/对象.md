# 对象

## 基础

<Todo />


## 原型与原型链

<Todo />

## 属性描述符

<Todo />

## 属性迭代

<Todo />

## new操作符原理

在JavaScript中，有两种方式可以创建一个对象：

通过字面量创建：

```js
const person = {
  name: 'zxp'
}
```

通过 `new` 操作符创建：

```js
function Person(name) {
  this.name = name
}
const p = new Person('zxp')
```

通过字面量创建对象究其本质还是通过 `new` 来创建，其语法等同于 `new Object()` 。

**原理解析**

让我们把上述的列子再丰富一点：

```js
function Person(name) {
  this.name = name
}
Person.prototype.say = function() {
  console.log(`hello, my name is ${this.name}`)
}
const p = new Person('zxp')
p.say()
```

上述代码中，之所以能调用 `p.say()` ，是因为通过 `new` 创建一个对象时，会将构造函数的 `prototype` 属性作为对象的原型，如果对象 `p` 访问了自身不存在的成员，则会在其原型链上进行查找。

因此，如果要实现自己的 `new` 操作符，我们需要更改原始对象的原型。代码如下：

```js
function newObject(Constructor, ...args) {
  const o = {}
  Object.setPrototypeOf(o, Constructor.prototype)
  return o
}
```

这样，当我们获取一个不属于对象本身的成员时，会在构造函数的 `prototype` 属性中查找。

::: tip
将返回对象的原型设置为构造函数的 `prototype` ，其实就是《你不知道的JavaScript 上卷》中反复提到的“委托”概念。我们将返回对象中不存在的成员操作委托给了“另一个对象”，而在JavaScript中，这种委托关系会形成一个链，即所谓原型链。
:::

除此之外，`new` 操作符还会执行构造函数本身，因此我们的实现也要改进一下：

```js
function newObject(Constructor, ...args) {
  const o = {}
  Object.setPrototypeOf(o, Constructor.prototype)
  const result = Constructor.apply(o, args)
  return (result && typeof result === 'object') ? result : o
}
```

`new` 创建对象时，如果构造函数返回了一个新的对象，则直接以该对象为 `new` 的结果对象。在上述代码中，我们根据构造函数的返回值做了判断，实现了这个特性。

总结一下， `new` 创建对象会做这两件事：

1. 将一个空白对象的原型设置为委托对象，因为通过构造函数创建对象，因此该委托对象为构造函数的 `prototype` 对象
2. 调用构造函数，初始化创建的对象






## Object.create

`Object.create` 接受一个对象作为参数，返回另一个对象，返回的对象以传入的对象为原型。

```js
const person = {
  say() {
    console.log(`Hi, my name is ${this.name}`)
  }
}

const p = Object.create(person)
p.name = 'Jack'

p.say()
```

尽管变量 `p` 并没有声明 `say` 函数，但由于 `person` 对象为 `p` 对象的原型，当调用 `p.say()` 时，会在原型链查找，查找到 `person` 对象的 `say` 函数，从而调用成功。

下图展示了对象 `p` 的原型链：

![](./images/object-1.png)

**polyfill**

核心思路是 **改变返回的对象的原型为传入的对象**，因此可以从以下步骤入手：

1. 创建一个新对象
2. 将对象的 `[[Prototype]]` 指向传入对象
3. 返回该对象

```js
function objectCreate(proto) {
  const o = {}
  Object.setPrototypeOf(o, proto)
  return o
}
```

考虑到 `Object.setPrototypeOf` 在IE 11以后的版本才被实现，还可以考虑另一种方案：返回的对象通过一个构造函数创建，将此构造函数的 `prototype` 属性指向传入的对象。代码如下：

```js
function objectCreate2(proto) {
  function F() {}
  F.prototype = proto
  return new F()
}
```

## 反射/内省

<Todo />

## 手写系列

### 手写 `new`

参考 [new操作符原理](./对象.md#new操作符原理)。



### 手写深拷贝

要点：

* 基本类型直接复制
* 对象、数组按照深度进行递归处理
* 函数的处理
* Set/Map/Date/RegExp等非plain object的处理
* 循环引用等极端情况处理（重点）

数据类型

* 基本型
   * undefined
   * null
   * number
   * string
   * boolean
   * bigint
   * symbol
* 引用型
   * Object
   * Array
   * Date
   * RegExp
   * Set
   * Map

实现代码如下：

```javascript
function isObjectType(value, type) {
  let objectType = Object.prototype.toString.call(value)
  objectType = objectType.substring(8, objectType.length - 1)
  return objectType === type
}

function isPrimitive(value) {
  return value === null || ['boolean', 'string', 'number', 'bigint', 'symbol', 'undefined'].indexOf(typeof value) >= 0
}

function isArray(value) {
  return isObjectType(value, 'Array')
}

function clone(value) {
  const refs = []
  const doClone = (val, parent) => {
    if (isPrimitive(val)) return val
    if (refs.indexOf(val) >= 0) return val
    // 特殊对象：数组
    if (isArray(val)) {
      const cloneVal = []
      for (let i = 0, len = val.length; i < len; i++) {
        cloneVal[i] = doClone(val[i])
      }
      return cloneVal
    }
    // 特殊对象：正则表达式
    if (isObjectType(val, 'RegExp')) {
      return new RegExp(val)
    }
    // 特殊对象：日期
    if (isObjectType(val, 'Date')) {
      return new Date(val)
    }

    // 普通对象
    refs.push(val)
    const cloneVal = {}
    Object.keys(val).forEach(key => {
      cloneVal[key] = doClone(val[key], val)
    })
    return cloneVal
  }
  return doClone(value)
}
```

### 手写 `instanceOf`

```ts
function instanceOf(o: any, constructor: Function): boolean {
  let curr = o
  while (curr) {
    const proto = curr.__proto__
    if (proto === constructor.prototype) return true
    curr = proto
  }
  return false
}

```

`instanceof`缺点：
- 无法检测基本数据类型，如`1 instanceof Number => false`

