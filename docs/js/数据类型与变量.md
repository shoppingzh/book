# 数据类型与变量

- 数据类型
   - 基本数据类型
   - ES6新增数据类型
   - symbol
   - bigint
- 变量提升
- 重学变量提升
- 暂时性死区


## 数据类型

JavaScript中有7种基本数据类型：
- undefined
- null
- string
- number
- boolean
- symbol（ES6）
- bigint（ES6）

除了这几种基本数据类型外，还存在大量的引用数据类型，对引用数据类型进行 `typeof` 运算的结果为 `object` 。

::: warning 注意
`typeof null` 的结果为 `object` 是一个特例，这是因为js中所有数据都可以表示为二进制，而二进制前3位为0的为对象类型，因为 `null` 的所有二进制位都是0，所以就被误判为对象类型。
:::

**基本数据类型与引用类型的区别？**

首先需要明确：**基本数据类型不是对象！** 如 `var a = 1` 声明了一个值为1的数值类型的变量，这并不是一个数值对象。但是为什么你可以调用 `a.toFixed(2)` 呢？这是因为js引擎会自动对变量 `a` 进行装箱，相当于调用了 `new Number(a).toFixed(2)`。

**symbol**

参见 [符号](./符号.md)

## 变量提升

**一个函数作用域内**，通过 `var` 声明的变量会被提升到函数作用域的顶部，如：

```js
function func() {
  console.log(b)
  var b = 2
}
```

上述代码中，`var b` 会被提升到函数的顶部，相当于：

```js
function func() {
  var b
  console.log(b)
  b = 2
}
```


需要注意的，只有声明会被提升，赋值并不会提升。

**关于作用域**

变量提升说明了一件事：

**`var` 是没有块级作用域的，同时也说明，在ES6以前，没有块级作用域的概念。**

其他的编程语言如C、Java等都是有块级作用域的，例如：

```c
for (int i = 0; i < 10; i++) {
  int a = 1;
}
```

`for` 循环大括号内包裹的都是块级作用域，也就是说，每次循环进来时，声明的 `int a = 1` 都只针对于当前作用域，在外部是访问不到的。

但是在JavaScript中，`if` / `for` 等语句是没有块级作用域的，所以同样的代码会发生看起来很奇怪的结果：

```js
for (var i = 0; i < 10; i++) {
}
console.log(i) // 10
```

因为没有块级作用域，所以 `var` 被提升了，代码其实变成了这样：

```js
var i
for (i = 0; i < 10; i++) {
}
console.log(i)
```

## 重学变量提升 <badge type="danger" text="重点" />

我们都知道：**作用域下的 `var` 声明会被提升到顶部。** 可是，为什么会这样呢？

大家都说JavaScript是解释型的语言，给人一种错觉好像JavaScript并不像C、Java这些语言一样经历编译过程。但错觉仅仅是错觉，很难想象你写下的一行代码 `var a = 1` 不会经历词法分析、语法分析阶段，因为计算机是不能执行这些高级语言的代码的，这些阶段其实就共同构成了编译阶段。

所以，所谓解释型语言，无非是将编译与执行的过程合二为一而已。而变量提升，就是发生在编译阶段。


```js
console.log(a)
var a = 1
```

上面的这段代码，在编译阶段会 **找到所有的变量声明，并用合适的作用域将其关联起来。** 而代码 `var a = 1` 其实包含了声明与赋值两个部分：

```js
var a // 声明
a = 1 // 赋值
```

由于 `var a` 是编译阶段发生的，而 `a = 1` 发生在运行阶段。所以， `var a` 被提升到了作用域的顶部，变成了：

```js
var a
console.log(a)
a = 1
```

因此，代码的执行结果会是 `undefined` ，这就是变量提升真正的内涵所在。

> 参考自 `《你不知道的JavaScript 上卷》`。

## 变量提升 - 函数优先原则 <badge type="danger" text="重点" />

js中的声明分为变量声明与函数声明两种，提升时，总遵循 **函数优先** 的原则。

```js
console.log(foo) // [Function: foo]

function foo() {
  console.log(1)
}

console.log(foo) // [Function: foo]

var foo = 1

console.log(foo) // 1
```

以上代码等同于：

```js
// 编译阶段
function foo() {
  console.log(1)
}
var foo

// 执行阶段
console.log(foo)
console.log(foo)

foo = 1
console.log(foo)
```

编译阶段函数声明与变量声明同时提升到顶部，由于函数声明优先，所以前两次打印 `foo` 时，输出的是函数本身。

而后， `foo = 1` 这行代码对 `foo` 声明进行了重新赋值，因此输出为 `1`。


## 暂时性死区

TODO


## 总结

- 要想彻底弄懂变量提升，需先弄懂js的编译与执行原理。