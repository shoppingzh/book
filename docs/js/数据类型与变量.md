# 数据类型与变量

- 数据类型
   - 基本数据类型
   - ES6新增数据类型
   - symbol
   - bigint
- 变量提升
- 重学变量提升
- 暂时性死区


## 数据类型

JavaScript中有7种基本数据类型：
- undefined
- null
- string
- number
- boolean
- symbol（ES6）
- bigint（ES6）

除了这几种基本数据类型外，还存在大量的引用数据类型，对引用数据类型进行 `typeof` 运算的结果为 `object` 。

**symbol**

参见 [Symbol](./Symbol.md)

## 变量提升

**一个函数作用域内**，通过 `var` 声明的变量会被提升到函数作用域的顶部，如：

```js
function func() {
  console.log(b)
  var b = 2
}
```

上述代码中，`var b` 会被提升到函数的顶部，相当于：

```js
function func() {
  var b
  console.log(b)
  b = 2
}
```

## 暂时性死区

TODO

需要注意的，只有声明会被提升，赋值并不会提升。

**关于作用域**

变量提升说明了一件事：

**`var` 是没有块级作用域的，同时也说明，在ES6以前，没有块级作用域的概念。**

其他的编程语言如C、Java等都是有块级作用域的，例如：

```c
for (int i = 0; i < 10; i++) {
  int a = 1;
}
```

`for` 循环大括号内包裹的都是块级作用域，也就是说，每次循环进来时，声明的 `int a = 1` 都只针对于当前作用域，在外部是访问不到的。

但是在JavaScript中，`if` / `for` 等语句是没有块级作用域的，所以同样的代码会发生看起来很奇怪的结果：

```js
for (var i = 0; i < 10; i++) {
}
console.log(i) // 10
```

因为没有块级作用域，所以 `var` 被提升了，代码其实变成了这样：

```js
var i
for (i = 0; i < 10; i++) {
}
console.log(i)
```

## 重学变量提升 <badge type="danger" text="重点" />

我们都知道：**作用域下的 `var` 声明会被提升到顶部。** 可是，为什么会这样呢？

大家都说JavaScript是解释型的语言，给人一种错觉好像JavaScript并不像C、Java这些语言一样经历编译过程。但错觉仅仅是错觉，很难想象你写下的一行代码 `var a = 1` 不会经历词法分析、语法分析阶段，因为计算机是不能执行这些高级语言的代码的，这些阶段其实就共同构成了编译阶段。

所以，所谓解释型语言，无非是将编译与执行的过程合二为一而已。而变量提升，就是发生在编译阶段。


```js
console.log(a)
var a = 1
```

上面的这段代码，在编译阶段会 **找到所有的变量声明，并用合适的作用域将其关联起来。** 而代码 `var a = 1` 其实包含了声明与赋值两个部分：

```js
var a // 声明
a = 1 // 赋值
```

由于 `var a` 是编译阶段发生的，而 `a = 1` 发生在运行阶段。所以， `var a` 被提升到了作用域的顶部，变成了：

```js
var a
console.log(a)
a = 1
```

因此，代码的执行结果会是 `undefined` ，这就是变量提升真正的内涵所在。

> 参考自 `《你不知道的JavaScript 上卷》`。
